\chapter{算法基础}

\section{快速排序}
\subsection{AcWing 785. 快速排序}

\begin{titledbox}{AcWing 785. 快速排序}
  给定你一个长度为 $n$ 的整数数列。请你使用快速排序对这个数列按照从小到大进行排序。并将排好序的数列按顺序输出。

  输入格式：

  输入共两行，第一行包含整数 $n$。第二行包含 $n$ 个整数（所有整数均在 $1 \sim 10^9$ 范围内），表示整个数列。

  输出格式：

  输出共一行，包含 $n$ 个整数，表示排好序的数列。

  数据范围：$1 \le n \le 100000$

  输入样例：

  5

  3 1 2 4 5

  输出样例：

  1 2 3 4 5
\end{titledbox}

快速排序算法基于\textbf{分治}算法，以一个数来作为分治的节点。

随机选取数组中的某个元素$x$作为分界点，操作数组中的元素使得数组被分割为两个部分，左边一侧的元素小于等于$x$，右边一侧则大于等于$x$。接下来递归的对左右两侧数组进行操作，直到最小数组只有一个元素则完成排序。

主要步骤如下：
\begin{enumerate}
  \item 确定分界点$x$，可取值：\lstinline{q[l]}, \lstinline{q[r]}, \lstinline{q[(l + r) >> 1]}, random value
  \item 调整数组，使得左边小于等于$x$，右边大于等于$x$
  \item 递归处理左右两段
\end{enumerate}

\begin{mycpptwocol}[quick sort]
    #include <stdio.h>
    #include <stdlib.h>
    
    void swap(int *q, int a, int b)
    {
        int tmp = q[a];
        q[a] = q[b];
        q[b] = tmp;
    }
    
    void quick_sort(int *q, int l, int r)
    {
        if (l >= r) {
            return;
        }
        int x = q[(l + r) >> 1];
        int i = l - 1;
        int j = r + 1;
        while (i < j) {
            do i++; while (q[i] < x);
            do j--; while (q[j] > x);
            if (i < j) {
                swap(q, i, j);
            }
        }
        quick_sort(q, l, j);
        quick_sort(q, j + 1, r);
    }
    
    int main()
    {
        int n;
        scanf("%d", &n);
        int *arr = (int *)calloc(sizeof(int), n);
        if (arr == NULL) {
            return -1;
        }
        for (int i = 0; i < n; i++) {
            scanf("%d", arr + i);
        }
        quick_sort(arr, 0, n - 1);
        for (int i = 0; i < n; i++) {
            printf("%d ", arr[i]);
        }
        free(arr);
        return 0;
    }
\end{mycpptwocol}

从上述代码段中可以清晰看到递归处理的过程，每次选取分界点，之后将左右两侧的元素进行调整，此处采用双指针算法。

\begin{keypoint}
    这里有两个问题：
    \begin{enumerate}
        \item 在选择x时选择\lstinline{q[l]}则在递归是不能选用\lstinline{i}，会出现边界问题 | \lstinline{i - 1, i}
        \item 在选择x时选择\lstinline{q[r]}则在递归是不能选用\lstinline{j}，会出现边界问题 | \lstinline{j, j + 1}
    \end{enumerate}

    边界用例可使用\lstinline{1, 2}这个例子，会有递归不结束的问题
\end{keypoint}

\begin{information}
  该算法\textbf{不稳定}，因为\lstinline{q[i]}和\lstinline{q[j]}相等的时候会发生交换。

  这里调整数组的部分是难点，怎么优雅的调整数组？暴力做法可以开辟两个辅助数组来存储。双指针做法优雅简洁。
\end{information}

时间复杂度分析：

\subsection{AcWing 786. 第k个数}
快速选择算法可选出有序数组中的第$k$个数，与快排中逻辑相同，左侧的元素都小于$x$右侧元素都大于$x$。如果左侧元素的数量大于等于$k$则表示第$k$个元素在左侧数组中，反之则在右侧数组中寻找$k-\text{left length}$的元素。

\begin{titledbox}{AcWing 786. 第k个数}
给定一个长度为 $n$ 的整数数列，以及一个整数 $k$，请用快速选择算法求出数列从小到大排序后的第 $k$ 个数。

输入格式：

第一行包含两个整数 $n$ 和 $k$。
第二行包含 $n$ 个整数（所有整数均在 $1 \sim 10^9$ 范围内），表示整数数列。

输出格式：

输出一个整数，表示数列的第 $k$ 小数。

数据范围：

$1 \le n \le 100000$,
$1 \le k \le n$

输入样例：

5 3

2 4 1 5 3


输出样例：

3
\end{titledbox}


\begin{mycpptwocol}[find kth smallest number]
    #include <stdio.h>
    #include <stdlib.h>

    int quick_select(int *q, int l, int r, int k)
    {
        if (r <= l) {
            return q[l];
        }
        int x = q[(l + r) >> 1];
        int i = l - 1;
        int j = r + 1;
        while (i < j) {
            do i++; while(q[i] < x);
            do j--; while(q[j] > x);
            if (i < j) {
                int tmp = q[i];
                q[i] = q[j];
                q[j] = tmp;
            }
        }
        int length = j - l + 1;
        if (length < k) {
            return quick_select(q, j + 1, r, k - length);
        } else {
            return quick_select(q, l, j, k);
        }
    }

    int main()
    {
        int n;
        int k;
        scanf("%d %d", &n, &k);
        int *arr = (int *)calloc(sizeof(int), n);
        if (arr == NULL) {
            return -1;
        }
        for (int i = 0; i < n; i++) {
            scanf("%d", arr + i);
        }
        int ret = quick_select(arr, 0, n - 1, k);
        printf("%d", ret);
        return 0;
    }
\end{mycpptwocol}

\section{归并排序}
归并排序同样是基于\textbf{分治}算法，不过是以整个数组的中间位置来分。

将数组分割成两个已经分别排序好的有序数组，再将其二者合并即可。此方法需要有单独的空间来存放合并的临时结果，再将临时结果写入到原始区域中。

主要步骤如下：
\begin{enumerate}
  \item 确定分界点，\lstinline{mid = (l + r) >> 1}
  \item 递归排序左右两边
  \item 归并，将两个有序的子数组合二为一
\end{enumerate}

\subsection{AcWing 787. 归并排序}
\begin{titledbox}{AcWing 787. 归并排序}
    给定你一个长度为 $n$ 的整数数列。请你使用归并排序对这个数列按照从小到大进行排序。并将排好序的数列按顺序输出。
  
    输入格式：
  
    输入共两行，第一行包含整数 $n$。第二行包含 $n$ 个整数（所有整数均在 $1 \sim 10^9$ 范围内），表示整个数列。
  
    输出格式：
  
    输出共一行，包含 $n$ 个整数，表示排好序的数列。
  
    数据范围：$1 \le n \le 100000$
  
    输入样例：
  
    5
  
    3 1 2 4 5
  
    输出样例：
  
    1 2 3 4 5
\end{titledbox}

\begin{mycpptwocol}[merge sort]
    #include <stdio.h>
    #include <stdlib.h>

    #define N 100010

    int backup[N];

    void merge_sort(int *q, int l, int r)
    {
        if (r <= l) {
            return;
        }
        int mid = (l + r) >> 1;
        merge_sort(q, l, mid);
        merge_sort(q, mid + 1, r);
        int k = 0;
        int i = l;
        int j = mid + 1;
        while (i <= mid && j <= r) {
            if (q[i] <= q[j]) {
                backup[k++] = q[i++];
            }
            if (q[j] < q[i]) {
                backup[k++] = q[j++];
            }
        }
        while (i <= mid) {
            backup[k++] = q[i++];
        }
        while (j <= r) {
            backup[k++] = q[j++];
        }
        
        for (i = l, j = 0; j < k; i++, j++) {
            q[i] = backup[j];
        }
    }

    int main()
    {
        int n;
        scanf("%d", &n);
        int *arr = (int *)calloc(sizeof(int), n);
        if (arr == NULL) {
            return -1;
        }
        for (int i = 0; i < n; i++) {
            scanf("%d", arr + i);
        }
        merge_sort(arr, 0, n - 1);
        for (int i = 0; i < n; i++) {
            printf("%d ", arr[i]);
        }
        return 0;
    }
\end{mycpptwocol}

双指针算法做归并

\begin{keypoint}
    这里归并两个子数组之后要写回去，\lstinline{backup}数组只是临时存储使用。
\end{keypoint}

\subsection{AcWing 788. 逆序对的数量}
\begin{titledbox}{AcWing 788. 逆序对的数量}
    给定一个长度为 $n$ 的整数数列，请你计算数列中的逆序对的数量。
    逆序对的定义如下：对于数列的第 $i$ 个和第 $j$ 个元素，如果满足 $i < j$ 且 $a[i] > a[j]$，则其为一个逆序对；否则不是。
    
    输入格式：

    第一行包含整数 $n$，表示数列的长度。第二行包含 $n$ 个整数，表示整个数列。
    
    输出格式：
    
    输出一个整数，表示逆序对的个数。

    数据范围

    $1 \le n \le 100000$，
    数列中的元素的取值范围 $[1,10^9]$。
    
    输入样例：

    2 3 4 5 6 1
    
    输出样例：
    
    5
\end{titledbox}

分治思路，将整个区间一分为二。考虑到归并排序的时候需要将两个有序数组合并，此时恰好可以做逆序对的统计。假设有一种算法，可以将数组排序的过程中统计该数组中的逆序对数量，则问题变为怎么统计两个有序数组中合起来的逆序对。

\begin{mycpptwocol}[归并排序计算逆序对数量]
    #include <stdio.h>
    #include <stdlib.h>

    long long merge_sort(int *q, int *tmp, int l, int r)
    {
        if (l >= r) {
            return 0;
        }
        int mid = (l + r) >> 1;
        // 左侧的数组已统计逆序对且已经排序，右侧同样
        long long res = merge_sort(q, tmp, l, mid) + merge_sort(q, tmp, mid + 1, r);
        // 统计两个有序数组合起来的逆序对数量
        int i = l;
        int j = mid + 1;
        int k = 0;
        while (i <= mid && j <= r) {
            if (q[i] > q[j]) {
                res += mid - i + 1;
                tmp[k++] = q[j++];
            } else {
                tmp[k++] = q[i++];
            }
        }
        
        while (i <= mid) {
            tmp[k++] = q[i++];
        }
        while (j <= r) {
            tmp[k++] = q[j++];
        }
        
        for (i = l, j = 0; i <= r; i++, j++) {
            q[i] = tmp[j];
        }
        
        return res;
    }

    int main()
    {
        int n;
        scanf("%d", &n);
        int *arr = (int *)calloc(n, sizeof(int));
        if (arr == NULL) {
            return -1;
        }
        int *tmp = (int *)calloc(n, sizeof(int));
        if (tmp == NULL) {
            free(arr);
            return -1;
        }
        for(int i = 0; i < n; i++) {
            scanf("%d", &arr[i]);
        }
        
        printf("%ld", merge_sort(arr, tmp, 0, n - 1));
        return 0;
    }
\end{mycpptwocol}
\section{二分}
整数二分和浮点数二分，二分即查找一个边界值，在左侧满足某种性质，右侧不满足。

二分用模版如下：
\begin{mycpptwocol}[二分模版]
    // 区间[l, r]被划分为[l, mid] 和 [mid + 1, r]时使用, 往左找
    int bsearch_1(int l, int r)
    {
        while (l < r) {
            mid = (l + r) / 2;
            if (Check(mid)) {
                r = mid;
            } else {
                l = mid + 1;
            }
        }
    }
    // 区间[l, r]被划分为[l, mid - 1] 和 [mid, r]时使用，往右找
    int bsearch_2(int l, int r)
    {
        while (l < r) {
            mid = (l + r + 1) / 2;
            if (Check(mid)) {
                l = mid;
            } else {
                r = mid - 1;
            }
        }
    }
\end{mycpptwocol}

\begin{keypoint}
    每次要保证答案在区间中。

    第二个模版加一的原因在于，如果某次循环结束后，\lstinline{l = r - 1}，如果不加1，此时因为向下取整的缘故\lstinline{mid = l}，check成功后\lstinline{l}被再次赋值为\lstinline{mid}即\lstinline{l}，则此时进入死循环。
\end{keypoint}

\subsection{AcWing 789. 数的范围}
\begin{titledbox}{AcWing 789. 数的范围}
给定一个按照升序排列的长度为 $n$ 的整数数组，以及 $q$ 个查询。对于每个查询，返回一个元素 $k$ 的起始位置和终止位置（位置从 $0$ 开始计数）。如果数组中不存在该元素，则返回\lstinline{-1 -1}。

输入格式：

第一行包含整数 $n$ 和 $q$，表示数组长度和询问个数。第二行包含 $n$ 个整数（均在 $1 \sim 10000$ 范围内），表示完整数组。接下来 $q$ 行，每行包含一个整数 $k$，表示一个询问元素。

输出格式：

共 $q$ 行，每行包含两个整数，表示所求元素的起始位置和终止位置。

数据范围
$1 \le n \le 100000$，
$1 \le q \le 10000$，
$1 \le k \le 10000$

输入样例：

6 3

1 2 2 3 3 4

3

4

5

输出样例：

3 4

5 5

-1 -1
\end{titledbox}


\begin{mycpptwocol}[binary search]
    #include <stdio.h>
    #include <stdlib.h>

    int binary_search_l(int *arr, int l, int r, int t)
    {
        while (l < r) {
            int mid = (l + r) >> 1;
            if (arr[mid] >= t) {
                r = mid;
            } else {
                l = mid + 1;
            }
        }
        if (arr[l] != t) {
            return -1;
        }
        return l;
    }

    int binary_search_r(int *arr, int l, int r, int t)
    {
        while (l < r) {
            int mid = (l + r) / 2 + 1;
            if (arr[mid] <= t) {
                l = mid;
            } else {
                r = mid - 1;
            }
        }
        if (arr[l] != t) {
            return -1;
        }
        return l;
    }

    int main()
    {
        int n;
        int q;
        scanf("%d %d", &n, &q);
        int *arr = (int *)calloc(sizeof(int), n);
        if (arr == NULL) {
            return -1;
        }
        for (int i = 0; i < n; i++) {
            scanf("%d", arr + i);
        }
        while(q--) {
            int t;
            scanf("%d", &t);
            printf("%d %d\n",
            binary_search_l(arr, 0, n - 1, t),
            binary_search_r(arr, 0, n - 1, t));
        }
        return 0;
    }
\end{mycpptwocol}

\begin{exclamation}
    这里不能使用\lstinline{bsearch}函数来完成左端点的搜索，因为该函数在面对重复值时返回值不确定，是未定义行为。
\end{exclamation}

\subsection{AcWing 790. 数的三次方根}
\begin{titledbox}{AcWing 790. 数的三次方根}
    给定一个浮点数 $n$，求它的三次方根。

    输入格式：

    共一行，包含一个浮点数 $n$。

    输出格式：

    共一行，包含一个浮点数，表示问题的解。
    
    注意，结果保留 $6$ 位小数。
    
    数据范围：

    $-10000 \le n \le 10000$
    
    输入样例：
    
    1000.00
    
    输出样例：

    10.000000
\end{titledbox}
\section{高精度}

\section{前缀和与差分}
\begin{enumerate}
    \item 前缀和可方便地求取数组中某个区间的元素和，或者矩阵的子矩阵的和 O(1)
    \item 差分和方便的将数组某个区间的所有元素加上一个数，O(1)时间复杂度
\end{enumerate}

\section{双指针算法}


\section{位运算}


\section{离散化}


\section{区间合并}