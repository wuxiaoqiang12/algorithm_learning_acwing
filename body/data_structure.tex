\chapter{数据结构}

\section{单链表}
\subsection{AcWing 826. 单链表}

\begin{titledbox}{AcWing 826. 单链表}
实现一个单链表，链表初始为空，支持三种操作：
\begin{enumerate}
    \itemsep=-5pt
    \item 向链表头插入一个数；
    \item 删除第 $k$ 个插入的数后面的数；
    \item 在第 $k$ 个插入的数后插入一个数。
\end{enumerate}

现在要对该链表进行 $M$ 次操作，进行完所有操作后，从头到尾输出整个链表。
\textbf{注意}: 题目中第 $k$ 个插入的数并不是指当前链表的第 $k$ 个数。例如操作过程中一共插入了 $n$ 个数，则按照插入的时间顺序，这 $n$ 个数依次为：第 $1$ 个插入的数，第 $2$ 个插入的数，$\dots$第 $n$ 个插入的数。

输入格式：

第一行包含整数 $M$，表示操作次数。接下来 $M$ 行，每行包含一个操作命令，操作命令可能为以下几种：

\begin{enumerate}
    \itemsep=-5pt
    \item H x，表示向链表头插入一个数 $x$。
    \item D k，表示删除第 $k$ 个插入的数后面的数（当 $k$ 为 $0$ 时，表示删除头结点）。
    \item I k x，表示在第 $k$ 个插入的数后面插入一个数 $x$（此操作中 $k$ 均大于 $0$）。
\end{enumerate}

输出格式：

共一行，将整个链表从头到尾输出。

数据范围：

$1 \le M \le 100000$ 所有操作保证合法。

\begin{inputblock}
    10 \\
    H 9 \\
    I 1 1 \\
    D 1 \\
    D 0 \\
    H 6 \\
    I 3 6 \\
    I 4 5 \\
    I 4 5 \\
    I 3 4 \\
    D 6
\end{inputblock}
\begin{outputblock}
    6 4 6 5
\end{outputblock}
\end{titledbox}

\begin{mycpptwocol}[linked list]
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

#define N 100010
int idx; // 标识节点
int head; // 头节点指向的元素
int e[N]; // element array
int ne[N]; // next array

void Init()
{
    idx = -1;
    head = -1;
}
    
// 在头节点后插入元素
void AddHead(int x) {
    e[++idx] = x;
    ne[idx] = head;
    head = idx;
}

// 在k节点之后插入元素
void Add(int k, int x)
{
    e[++idx] = x;
    ne[idx] = ne[k];
    ne[k] = idx;
}

// 删除k之后的那个元素
void Remove(int k) {
    ne[k] = ne[ne[k]];
}

int main()
{
    Init();
    int n;
    scanf("%d", &n);
    while (n--) {
        int x;
        int k;
        char op;
        scanf(" %c", &op);
        if (op == 'H') {
            scanf("%d", &x);
            AddHead(x);
        }
        if (op == 'I') {
            scanf("%d %d", &k, &x);
            Add(k - 1, x);
        }
        if (op == 'D') {
            scanf("%d", &k);
            if (k == 0) {
                head = ne[head];
            }
            Remove(k - 1);
        }
    }

    int tmp = head;
    while (tmp != -1) {
        printf("%d ", e[tmp]);
        tmp = ne[tmp];
    }
    return 0;
}
\end{mycpptwocol}

\section{双链表}

\subsection{AcWing 827. 双链表}
\begin{titledbox}{AcWing 827. 双链表}
实现一个双链表，双链表初始为空，支持 $5$ 种操作：

\begin{enumerate}
    \itemsep=-5pt
    \item 在最左侧插入一个数；
    \item 在最右侧插入一个数；
    \item 将第 $k$ 个插入的数删除；
    \item 在第 $k$ 个插入的数左侧插入一个数；
    \item 在第 $k$ 个插入的数右侧插入一个数。
\end{enumerate}

现在要对该链表进行 $M$ 次操作，进行完所有操作后，从左到右输出整个链表。\textbf{注意}: 题目中第 $k$ 个插入的数并不是指当前链表的第 $k$ 个数。例如操作过程中一共插入了 $n$ 个数，则按照插入的时间顺序，这 $n$ 个数依次为：第 $1$ 个插入的数，第 $2$ 个插入的数，…第 $n$ 个插入的数。

输入格式：

第一行包含整数 $M$，表示操作次数。接下来 $M$ 行，每行包含一个操作命令，操作命令可能为以下几种：

\begin{enumerate}
    \itemsep=-5pt
    \item L x，表示在链表的最左端插入数 $x$。
    \item R x，表示在链表的最右端插入数 $x$。
    \item D k，表示将第 $k$ 个插入的数删除。
    \item IL k x，表示在第 $k$ 个插入的数左侧插入一个数。
    \item IR k x，表示在第 $k$ 个插入的数右侧插入一个数。
\end{enumerate}

输出格式：

共一行，将整个链表从左到右输出

数据范围：

$1 \le M \le 100000$ 所有操作保证合法。

\begin{inputblock}
    10 \\
    R 7 \\
    D 1 \\
    L 3 \\
    IL 2 10 \\
    D 3 \\
    IL 2 7 \\
    L 8 \\
    R 9 \\
    IL 4 7 \\
    IR 2 2
\end{inputblock}
\begin{outputblock}
    8 7 7 3 2 9
\end{outputblock}
\end{titledbox}

\begin{mycpptwocol}[双链表]
#include <stdio.h>
#include <stdlib.h>

#define N 100010

int e[N];
int l[N];
int r[N];
int idx = 1;

void Init()
{
    r[0] = 1;
    l[1] = 0;
    idx = 1;
}

void AddRight(int k, int x)
{
    e[++idx] = x;
    r[idx] = r[k];
    l[r[k]] = idx;
    l[idx] = k;
    r[k] = idx;
}

void Remove(int k)
{
    r[l[k]] = r[k];
    l[r[k]] = l[k];
}

int main()
{
    Init();
    int n;
    scanf("%d", &n);
    while (n--) {
        char op[3];
        scanf("%s", op);
        int k;
        int x;
        if (op[0] == 'R') {
            scanf("%d", &x);
            AddRight(l[1], x);
        }
        if (op[0] == 'D') {
            scanf("%d", &k);
            Remove(k + 1);
        }
        if (op[0] == 'L') {
            scanf("%d", &x);
            AddRight(0, x);
        }
        if (op[0] == 'I') {
            scanf("%d %d", &k, &x);
            if (op[1] == 'L') {
                AddRight(l[k + 1], x);
            } else {
                AddRight(k + 1, x);
            }
        }
    }
    for (int i = r[0]; i != 1; i = r[i]) {
        printf("%d ", e[i]);
    }
    return 0;
}
\end{mycpptwocol}

\section{栈}
\subsection{AcWing 828. 模拟栈}
\begin{titledbox}{AcWing 828. 模拟栈}
实现一个栈，栈初始为空，支持四种操作：

\begin{enumerate}
    \itemsep=-5pt
    \item push x - 向栈顶插入一个数 $x$；
    \item pop - 从栈顶弹出一个数；
    \item empty - 判断栈是否为空；
    \item query - 查询栈顶元素
\end{enumerate}

现在要对栈进行 $M$ 个操作，其中的每个操作 $3$ 和操作 $4$ 都要输出相应的结果。

输入格式：

第一行包含整数 $M$，表示操作次数。接下来 $M$ 行，每行包含一个操作命令，操作命令为 push x，pop，empty，query 中的一种。

输出格式：

对于每个 empty 和 query 操作都要输出一个查询结果，每个结果占一行。其中，empty 操作的查询结果为 YES 或 NO，query 操作的查询结果为一个整数，表示栈顶元素的值。

数据范围：

$1 \le M \le 100000$, $1 \le x \le 10^9$ 所有操作保证合法。

\begin{inputblock}
    10 \\
    push 5  \\
    query  \\
    push 6  \\
    pop  \\
    query  \\
    pop  \\
    empty  \\
    push 4  \\
    query  \\
    empty 
\end{inputblock}
\begin{outputblock}
    5 \\
    5 \\
    YES \\
    4 \\
    NO
\end{outputblock}
\end{titledbox}

\begin{mycpptwocol}[模拟栈]
#include <stdio.h>
#include <stdlib.h>

int main()
{
    int n;
    scanf("%d", &n);
    int *stack = (int *)calloc(n, sizeof(int));
    int top = 0;
    while (n--) {
        char op[10];
        scanf("%s", op);
        int x;
        if (strcmp(op, "push") == 0) {
            scanf("%d", &x);
            stack[top++] = x;
        }
        if (strcmp(op, "query") == 0) {
            printf("%d\n", stack[top - 1]);
        }
        if (strcmp(op, "pop") == 0) {
            top--;
        }
        if (strcmp(op, "empty") == 0) {
            printf("%s\n", top == 0 ? "YES" : "NO");
        }
    }
    free(stack);
    return 0;
}
\end{mycpptwocol}
\subsection{AcWing 3302. 表达式求值}

\section{队列}
\subsection{AcWing 829. 模拟队列}

\begin{titledbox}{AcWing 829. 模拟队列}
实现一个队列，队列初始为空，支持四种操作：

\begin{enumerate}
    \itemsep=-5pt
    \item push x - 向队尾插入一个数 $x$；
    \item pop - 从队头弹出一个数；
    \item empty - 判断队列是否为空；
    \item query - 查询队头元素
\end{enumerate}

现在要对队列进行 $M$ 个操作，其中的每个操作 $3$ 和操作 $4$ 都要输出相应的结果。

输入格式：

第一行包含整数 $M$，表示操作次数。接下来 $M$ 行，每行包含一个操作命令，操作命令为 push x，pop，empty，query 中的一种。

输出格式：

对于每个 empty 和 query 操作都要输出一个查询结果，每个结果占一行。其中，empty 操作的查询结果为 YES 或 NO，query 操作的查询结果为一个整数，表示栈顶元素的值。

数据范围：

$1 \le M \le 100000$, $1 \le x \le 10^9$ 所有操作保证合法。

\begin{inputblock}
    10 \\
    push 6 \\
    empty \\
    query \\
    pop \\
    empty \\
    push 3 \\
    push 4 \\
    pop \\
    query \\
    push 6
\end{inputblock}
\begin{outputblock}
    NO \\
    YES \\
    6 \\
    4
\end{outputblock}
\end{titledbox}

\begin{mycpptwocol}[模拟队列]
#include <stdio.h>
#include <stdbool.h>

#define N 100010
int queue[N];
int tail;
int head;

void push(int x)
{
    queue[++tail] = x;
}

bool isEmpty()
{
    return head == tail;
}

void pop()
{
    head++;
}

int query()
{
    return queue[head + 1];
}

int main()
{
    int n;
    scanf("%d", &n);
    char op[10];
    while (n--) {
        scanf("%s", op);
        if (strcmp(op, "push") == 0) {
            int x;
            scanf("%d", &x);
            push(x);
        }
        if (strcmp(op, "pop") == 0) {
            pop();
        }
        if (strcmp(op, "empty") == 0) {
            printf("%s\n", isEmpty() ? "YES" : "NO");
        }
        if (strcmp(op, "query") == 0) {
            printf("%d\n", query());
        }
    }
    return 0;
}

\end{mycpptwocol}



\section{单调栈}

\subsection{AcWing 830. 单调栈}

\begin{titledbox}{AcWing 830. 单调栈}
给定一个长度为 $N$ 的整数数列，输出每个数左边第一个比它小的数，如果不存在则输出 $-1$。

输入格式：

第一行包含整数 $N$，表示数列长度。第二行包含 $N$ 个整数，表示整数数列。

输出格式：

共一行，包含 $N$ 个整数，其中第 $i$ 个数表示第 $i$ 个数的左边第一个比它小的数，如果不存在则输出 $-1$。

数据范围：

$1 \le N \le 10^5$，$1 \le \text{数列中元素} \le 10^9$

\begin{inputblock}
    5 \\
    3 4 2 7 5
\end{inputblock}
\begin{outputblock}
    -1 3 -1 2 2
\end{outputblock}

\end{titledbox}

\begin{mycpptwocol}[单调栈]
#include <stdio.h>
#include <stdlib.h>

int main()
{
    int n;
    scanf("%d", &n);
    int *stack = (int *)calloc(sizeof(int), n);
    int top = 0;
    while (n--) {
        int x;
        scanf("%d", &x);
        while (top != 0 && stack[top] >= x) {
            top--;
        }
        if (top == 0) {
            printf("%d ", -1);
        } else {
            printf("%d ", stack[top]);
        }
        stack[++top] = x;
    }
    free(stack);
    return 0;
}
\end{mycpptwocol}

\section{单调队列}
\subsection{AcWing 154. 滑动窗口}

\begin{titledbox}{AcWing 154. 滑动窗口}
给定一个大小为 $n \le 10^6$ 的数组。有一个大小为 $k$ 的滑动窗口，它从数组的最左边移动到最右边。你只能在窗口中看到 $k$ 个数字。每次滑动窗口向右移动一个位置。

以下是一个例子：

该数组为 \lstinline{[1 3 -1 -3 5 3 6 7]}，$k$ 为 $3$。

\begin{tabular}{|c|c|c|}
    \hline
        窗口位置 & 最小值 & 最大值 \\ \hline
        [1  3  -1] -3  5  3  6  7 & -1 & 3 \\ \hline
        1 [3  -1  -3] 5  3  6  7 & -3 & 3 \\ \hline
        1  3 [-1  -3  5] 3  6  7 & -3 & 5 \\ \hline
        1  3  -1 [-3  5  3] 6  7 & -3 & 5 \\ \hline
        1  3  -1  -3 [5  3  6] 7 & 3 & 6 \\ \hline
        1  3  -1  -3  5 [3  6  7] & 3 & 7 \\ \hline
\end{tabular}

你的任务是确定滑动窗口位于每个位置时，窗口中的最大值和最小值。

输入格式：
输入包含两行。 第一行包含两个整数 $n$ 和 $k$，分别代表数组长度和滑动窗口的长度。第二行有 $n$ 个整数，代表数组的具体数值。同行数据之间用空格隔开。

输出格式：
输出包含两个。第一行输出，从左至右，每个位置滑动窗口中的最小值。第二行输出，从左至右，每个位置滑动窗口中的最大值。
    
\begin{inputblock}
    8 3 \\
    1 3 -1 -3 5 3 6 7
\end{inputblock}
\begin{outputblock}
    -1 -3 -3 -3 3 3 \\
    3 3 5 5 6 7
\end{outputblock}
    
\end{titledbox}

\begin{mycpptwocol}[滑动窗口：单调队列]
#include <stdio.h>
#include <stdlib.h>

int main()
{
    int n;
    int k;
    scanf("%d %d", &n, &k);
    int *a = (int *)calloc(sizeof(int), n);
    for (int i = 0; i < n; i++) {
        scanf("%d", a + i);
    }
    int *queue = (int *)calloc(sizeof(int), n);
    int head = 0;
    int tail = -1;
    for (int i = 0; i < n; i++) {
        if (head <= tail && i - k + 1 > queue[head]) {
            head++;
        }
        while (head <= tail && a[queue[tail]] >= a[i]) {
            tail--;
        }
        queue[++tail] = i;
        if (i >= k - 1) {
            printf("%d ", a[queue[head]]);
        }
    }
    puts("");
    head = 0;
    tail = -1;
    for (int i = 0; i < n; i++) {
        if (head <= tail && i - k + 1 > queue[head]) {
            head++;
        }
        while (head <= tail && a[queue[tail]] <= a[i]) {
            tail--;
        }
        queue[++tail] = i;
        if (i >= k - 1) {
            printf("%d ", a[queue[head]]);
        }
    }
    free(queue);
    free(a);
    return 0;
}
\end{mycpptwocol}
\section{KMP}
\subsection{AcWing 831. KMP字符串}

\section{Trie}
\subsection{AcWing 835. Trie字符串统计}
\subsection{AcWing 143. 最大异或对}

\section{并查集}
\subsection{AcWing 836. 合并集合}
\subsection{AcWing 837. 连通块中点的数量}
\subsection{AcWing 240. 食物链}

\section{堆}
\subsection{AcWing 838. 堆排序}

\begin{titledbox}{AcWing 838. 堆排序}
输入一个长度为 $n$ 的整数数列，从小到大输出前 $m$ 小的数。

输入格式：

第一行包含整数 $n$ 和 $m$。第二行包含 $n$ 个整数，表示整数数列。

输出格式：
共一行，包含 $m$ 个整数，表示整数数列中前 $m$ 小的数。

数据范围：

$1 \le m \le n \le 10^5$，$1 \le 数列中元素 \le 10^9$

\begin{inputblock}
    5 3 \\
    4 5 1 3 2
\end{inputblock}
\begin{outputblock}
    1 2 3
\end{outputblock}
        
\end{titledbox}

\begin{mycpptwocol}[堆排序]
#include <stdio.h>
#include <stdlib.h>

#define N 100010
int h[N];
int size;

void down(int k)
{
    int t = k;
    if (2 * k <= size && h[2 * k] < h[t]) {
        t = 2 * k;
    }
    if (2 * k + 1 <= size && h[2 * k + 1] < h[t]) {
        t = 2 * k + 1;
    }
    if (t != k) {
        int tmp = h[t];
        h[t] = h[k];
        h[k] = tmp;
        down(t);
    }
}

int main()
{
    int n;
    int m;
    scanf("%d %d", &n, &m);
    for (int i = 1; i < n + 1; i++) {
        scanf("%d", &h[i]);
    }
    size = n;
    for (int i = n / 2; i > 0; i--) {
        down(i);
    }
    
    while (m--) {
        printf("%d ", h[1]);
        h[1] = h[size];
        size--;
        down(1);
    }
    return 0;
}
\end{mycpptwocol}

\subsection{AcWing 839. 模拟堆}

\begin{mycpptwocol}[可修改任意元素的堆]
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define N 100010
int heap[N];
int hp[N];
int ph[N];
int size;

void Swap(int *a, int *b)
{
	int tmp = *a;
	*a = *b;
	*b = tmp;
}

void HeapSwap(int k, int t)
{
	Swap(&ph[hp[k]], &ph[hp[t]]);
	Swap(&hp[k], &hp[t]);
	Swap(&heap[k], &heap[t]);
}

void Up(int k)
{
	while (k / 2 > 0 && heap[k / 2] > heap[k]) {
		HeapSwap(k, k / 2);
		k >>= 1;
	}
}

void Down(int k)
{
	int t = k;
	if (2 * k <= size && heap[2 * k] < heap[t]) {
		t = 2 * k;
	}
	if (2 * k + 1 <= size && heap[2 * k + 1] < heap[t]) {
		t = 2 * k + 1;
	}
	if (k != t) {
		HeapSwap(k, t);
		Down(t);
	}
}

int main()
{
	int n;
	scanf("%d", &n);
	int idx = 0;
	while (n--) {
		char op[3];
		scanf("%s", op);
		int x;
		if (strcmp(op, "I") == 0) {
			scanf("%d", &x);
			heap[++size] = x;
			hp[size] = ++idx;
			ph[idx] = size;
			Up(size);
		}
		if (strcmp(op, "PM") == 0) {
			printf("%d\n", heap[1]);
		}
		if (strcmp(op, "DM") == 0) {
			HeapSwap(1, size);
			size--;
			Down(1);
		}
		if (strcmp(op, "D") == 0) {
			int k;
			scanf("%d", &k);
			k = ph[k];
			HeapSwap(k, size--);
			Down(k);
			Up(k);
		}
		if (strcmp(op, "C") == 0) {
			int k;
			scanf("%d %d", &k, &x);
			k = ph[k];
			heap[k] = x;
			Down(k);
			Up(k);
		}
	}
	return 0;
}
\end{mycpptwocol}

\section{哈希表}
\subsection{AcWing 840. 模拟散列表}
\subsection{AcWing 841. 字符串哈希}